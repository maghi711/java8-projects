<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java8-projects</a> &gt; <a href="index.source.html" class="el_package">jeval</a> &gt; <span class="el_source">ExpressionTree.java</span></div><h1>ExpressionTree.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2007 Robert Breidecker.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jeval;

import jeval.function.Function;
import jeval.function.FunctionConstants;
import jeval.function.FunctionException;
import jeval.function.FunctionResult;
import jeval.operator.Operator;

/**
 * Represents an expression tree made up of a left operand, right operand,
 * operator and unary operator.
 */
public class ExpressionTree {

	// The left node in the tree.
<span class="nc" id="L32">	private Object leftOperand = null;</span>

	// The right node in the tree.
<span class="nc" id="L35">	private Object rightOperand = null;</span>

	// The operator for the two operands.
<span class="nc" id="L38">	private Operator operator = null;</span>

	// The unary operator, if one exists.
<span class="nc" id="L41">	private Operator unaryOperator = null;</span>

	// The Evaluator object processing this tree.
<span class="nc" id="L44">	private Evaluator evaluator = null;</span>

	/**
	 * Creates a new ExpressionTree.
	 * 
	 * @param evaluator
	 *            The Evaluator object processing this tree.
	 * @param leftOperand
	 *            The left operand to place as the left node of the tree.
	 * @param rightOperand
	 *            The right operand to place as the right node of the tree.
	 * @param operator
	 *            The operator to place as the operator node of the tree.
	 * @param unaryOperator
	 *            The new unary operator for this tree.
	 */
	public ExpressionTree(final Evaluator evaluator, final Object leftOperand,
			final Object rightOperand, final Operator operator,
<span class="nc" id="L62">			final Operator unaryOperator) {</span>

<span class="nc" id="L64">		this.evaluator = evaluator;</span>
<span class="nc" id="L65">		this.leftOperand = leftOperand;</span>
<span class="nc" id="L66">		this.rightOperand = rightOperand;</span>
<span class="nc" id="L67">		this.operator = operator;</span>
<span class="nc" id="L68">		this.unaryOperator = unaryOperator;</span>
<span class="nc" id="L69">	}</span>

	/**
	 * Returns the left operand of this tree.
	 * 
	 * @return The left operand of this tree.
	 */
	public Object getLeftOperand() {
<span class="nc" id="L77">		return leftOperand;</span>
	}

	/**
	 * Returns the right operand of this tree.
	 * 
	 * @return The right operand of this tree.
	 */
	public Object getRightOperand() {
<span class="nc" id="L86">		return rightOperand;</span>
	}

	/**
	 * Returns the operator for this tree.
	 * 
	 * @return The operator of this tree.
	 */
	public Operator getOperator() {
<span class="nc" id="L95">		return operator;</span>
	}

	/**
	 * Returns the unary operator for this tree.
	 * 
	 * @return The unary operator of this tree.
	 */
	public Operator getUnaryOperator() {
<span class="nc" id="L104">		return unaryOperator;</span>
	}

	/**
	 * Evaluates the operands for this tree using the operator and the unary
	 * operator.
	 * 
	 * @param wrapStringFunctionResults
	 *            Indicates if the results from functions that return strings
	 *            should be wrapped in quotes. The quote character used will be
	 *            whatever is the current quote character for this object.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encountered while processing the
	 *                expression.
	 */
	public String evaluate(final boolean wrapStringFunctionResults)
			throws EvaluationException {

<span class="nc" id="L123">		String rtnResult = null;</span>

		// Get the left operand.
<span class="nc" id="L126">		String leftResultString = null;</span>
<span class="nc" id="L127">		Double leftResultDouble = null;</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (leftOperand instanceof ExpressionTree) {</span>
<span class="nc" id="L130">			leftResultString = ((ExpressionTree) leftOperand)</span>
<span class="nc" id="L131">					.evaluate(wrapStringFunctionResults);</span>

			try {
<span class="nc" id="L134">				leftResultDouble = new Double(leftResultString);</span>
<span class="nc" id="L135">				leftResultString = null;</span>
<span class="nc" id="L136">			} catch (NumberFormatException exception) {</span>
<span class="nc" id="L137">				leftResultDouble = null;</span>
<span class="nc" id="L138">			}</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		} else if (leftOperand instanceof ExpressionOperand) {</span>

<span class="nc" id="L141">			final ExpressionOperand leftExpressionOperand = (ExpressionOperand) leftOperand;</span>

<span class="nc" id="L143">			leftResultString = leftExpressionOperand.getValue();</span>
<span class="nc" id="L144">			leftResultString = evaluator.replaceVariables(leftResultString);</span>

			// Check if the operand is a string or not. If it not a string,
			// then it must be a number.
<span class="nc bnc" id="L148" title="All 2 branches missed.">			if (!evaluator.isExpressionString(leftResultString)) {</span>
				try {
<span class="nc" id="L150">					leftResultDouble = new Double(leftResultString);</span>
<span class="nc" id="L151">					leftResultString = null;</span>
<span class="nc" id="L152">				} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L153">					throw new EvaluationException(&quot;Expression is invalid.&quot;, nfe);</span>
<span class="nc" id="L154">				}</span>

<span class="nc bnc" id="L156" title="All 2 branches missed.">				if (leftExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L157">					leftResultDouble = new Double(leftExpressionOperand</span>
<span class="nc" id="L158">							.getUnaryOperator().evaluate(</span>
<span class="nc" id="L159">									leftResultDouble.doubleValue()));</span>
				}
			} else {
<span class="nc bnc" id="L162" title="All 2 branches missed.">				if (leftExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L163">					throw new EvaluationException(&quot;Invalid operand for &quot;</span>
							+ &quot;unary operator.&quot;);
				}
			}
<span class="nc bnc" id="L167" title="All 2 branches missed.">		} else if (leftOperand instanceof ParsedFunction) {</span>

<span class="nc" id="L169">			final ParsedFunction parsedFunction = (ParsedFunction) leftOperand;</span>
<span class="nc" id="L170">			final Function function = parsedFunction.getFunction();</span>
<span class="nc" id="L171">			String arguments = parsedFunction.getArguments();</span>
<span class="nc" id="L172">			arguments = evaluator.replaceVariables(arguments);</span>
			
<span class="nc bnc" id="L174" title="All 2 branches missed.">			if (evaluator.getProcessNestedFunctions()) {</span>
<span class="nc" id="L175">				arguments = evaluator.processNestedFunctions(arguments);</span>
			}

			try {
<span class="nc" id="L179">				FunctionResult functionResult = </span>
<span class="nc" id="L180">					function.execute(evaluator, arguments);</span>
<span class="nc" id="L181">				leftResultString = functionResult.getResult();</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">				if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_NUMERIC) {
					
<span class="nc" id="L186">					Double resultDouble = new Double(leftResultString);</span>

					// Process a unary operator if one exists.
<span class="nc bnc" id="L189" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L190">						resultDouble = new Double(parsedFunction</span>
<span class="nc" id="L191">								.getUnaryOperator().evaluate(</span>
<span class="nc" id="L192">										resultDouble.doubleValue()));</span>
					}

					// Get the final result.
<span class="nc" id="L196">					leftResultString = resultDouble.toString();</span>
<span class="nc" id="L197">				} </span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">				else if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_STRING) {
					
					// The result must be a string result.
<span class="nc bnc" id="L202" title="All 2 branches missed.">					if (wrapStringFunctionResults) {</span>
<span class="nc" id="L203">						leftResultString = evaluator.getQuoteCharacter()</span>
								+ leftResultString
<span class="nc" id="L205">								+ evaluator.getQuoteCharacter();</span>
					}

<span class="nc bnc" id="L208" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L209">						throw new EvaluationException(&quot;Invalid operand for &quot;</span>
								+ &quot;unary operator.&quot;);
					}
				}
<span class="nc" id="L213">			} catch (FunctionException fe) {</span>
<span class="nc" id="L214">				throw new EvaluationException(fe.getMessage(), fe);</span>
<span class="nc" id="L215">			}</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">			if (!evaluator.isExpressionString(leftResultString)) {</span>
				try {
<span class="nc" id="L219">					leftResultDouble = new Double(leftResultString);</span>
<span class="nc" id="L220">					leftResultString = null;</span>
<span class="nc" id="L221">				} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L222">					throw new EvaluationException(&quot;Expression is invalid.&quot;, nfe);</span>
<span class="nc" id="L223">				}</span>
			}
<span class="nc" id="L225">		} else {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (leftOperand != null) {</span>
<span class="nc" id="L227">				throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
			}
		}

		// Get the right operand.
<span class="nc" id="L232">		String rightResultString = null;</span>
<span class="nc" id="L233">		Double rightResultDouble = null;</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">		if (rightOperand instanceof ExpressionTree) {</span>
<span class="nc" id="L236">			rightResultString = ((ExpressionTree) rightOperand)</span>
<span class="nc" id="L237">					.evaluate(wrapStringFunctionResults);</span>

			try {
<span class="nc" id="L240">				rightResultDouble = new Double(rightResultString);</span>
<span class="nc" id="L241">				rightResultString = null;</span>
<span class="nc" id="L242">			} catch (NumberFormatException exception) {</span>
<span class="nc" id="L243">				rightResultDouble = null;</span>
<span class="nc" id="L244">			}</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">		} else if (rightOperand instanceof ExpressionOperand) {</span>

<span class="nc" id="L248">			final ExpressionOperand rightExpressionOperand = (ExpressionOperand) rightOperand;</span>
<span class="nc" id="L249">			rightResultString = ((ExpressionOperand) rightOperand).getValue();</span>
<span class="nc" id="L250">			rightResultString = evaluator.replaceVariables(rightResultString);</span>

			// Check if the operand is a string or not. If it not a string,
			// then it must be a number.
<span class="nc bnc" id="L254" title="All 2 branches missed.">			if (!evaluator.isExpressionString(rightResultString)) {</span>
				try {
<span class="nc" id="L256">					rightResultDouble = new Double(rightResultString);</span>
<span class="nc" id="L257">					rightResultString = null;</span>
<span class="nc" id="L258">				} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L259">					throw new EvaluationException(&quot;Expression is invalid.&quot;, nfe);</span>
<span class="nc" id="L260">				}</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">				if (rightExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L263">					rightResultDouble = new Double(rightExpressionOperand</span>
<span class="nc" id="L264">							.getUnaryOperator().evaluate(</span>
<span class="nc" id="L265">									rightResultDouble.doubleValue()));</span>
				}
			} else {
<span class="nc bnc" id="L268" title="All 2 branches missed.">				if (rightExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L269">					throw new EvaluationException(&quot;Invalid operand for &quot;</span>
							+ &quot;unary operator.&quot;);
				}
			}
<span class="nc bnc" id="L273" title="All 2 branches missed.">		} else if (rightOperand instanceof ParsedFunction) {</span>

<span class="nc" id="L275">			final ParsedFunction parsedFunction = (ParsedFunction) rightOperand;</span>
<span class="nc" id="L276">			final Function function = parsedFunction.getFunction();</span>
<span class="nc" id="L277">			String arguments = parsedFunction.getArguments();</span>
<span class="nc" id="L278">			arguments = evaluator.replaceVariables(arguments);</span>
			
<span class="nc bnc" id="L280" title="All 2 branches missed.">			if (evaluator.getProcessNestedFunctions()) {</span>
<span class="nc" id="L281">				arguments = evaluator.processNestedFunctions(arguments);</span>
			}

			try {				
<span class="nc" id="L285">				FunctionResult functionResult = </span>
<span class="nc" id="L286">					function.execute(evaluator, arguments);</span>
<span class="nc" id="L287">				rightResultString = functionResult.getResult();</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">				if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_NUMERIC) {
					
<span class="nc" id="L292">					Double resultDouble = new Double(rightResultString);</span>

					// Process a unary operator if one exists.
<span class="nc bnc" id="L295" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L296">						resultDouble = new Double(parsedFunction</span>
<span class="nc" id="L297">								.getUnaryOperator().evaluate(</span>
<span class="nc" id="L298">										resultDouble.doubleValue()));</span>
					}

					// Get the final result.
<span class="nc" id="L302">					rightResultString = resultDouble.toString();</span>
<span class="nc" id="L303">				}</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">				else if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_STRING) {
					
					// The result must be a string result.
<span class="nc bnc" id="L308" title="All 2 branches missed.">					if (wrapStringFunctionResults) {</span>
<span class="nc" id="L309">						rightResultString = evaluator.getQuoteCharacter()</span>
								+ rightResultString
<span class="nc" id="L311">								+ evaluator.getQuoteCharacter();</span>
					}

<span class="nc bnc" id="L314" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L315">						throw new EvaluationException(&quot;Invalid operand for &quot;</span>
								+ &quot;unary operator.&quot;);
					}
				}
<span class="nc" id="L319">			} catch (FunctionException fe) {</span>
<span class="nc" id="L320">				throw new EvaluationException(fe.getMessage(), fe);</span>
<span class="nc" id="L321">			}</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">			if (!evaluator.isExpressionString(rightResultString)) {</span>
				try {
<span class="nc" id="L325">					rightResultDouble = new Double(rightResultString);</span>
<span class="nc" id="L326">					rightResultString = null;</span>
<span class="nc" id="L327">				} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L328">					throw new EvaluationException(&quot;Expression is invalid.&quot;, nfe);</span>
<span class="nc" id="L329">				}</span>
			}
<span class="nc bnc" id="L331" title="All 2 branches missed.">		} else if (rightOperand == null) {</span>
			// Do nothing.
		} else {
<span class="nc" id="L334">			throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
		}

		// Evaluate the the expression.
<span class="nc bnc" id="L338" title="All 4 branches missed.">		if (leftResultDouble != null &amp;&amp; rightResultDouble != null) {</span>
<span class="nc" id="L339">			double doubleResult = operator.evaluate(leftResultDouble</span>
<span class="nc" id="L340">					.doubleValue(), rightResultDouble.doubleValue());</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">			if (getUnaryOperator() != null) {</span>
<span class="nc" id="L343">				doubleResult = getUnaryOperator().evaluate(doubleResult);</span>
			}

<span class="nc" id="L346">			rtnResult = new Double(doubleResult).toString();</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">		} else if (leftResultString != null &amp;&amp; rightResultString != null) {</span>
<span class="nc" id="L348">			rtnResult = operator.evaluate(leftResultString, rightResultString);</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">		} else if (leftResultDouble != null &amp;&amp; rightResultDouble == null) {</span>
<span class="nc" id="L350">			double doubleResult = -1;</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">			if (unaryOperator != null) {</span>
<span class="nc" id="L353">				doubleResult = unaryOperator.evaluate(leftResultDouble</span>
<span class="nc" id="L354">						.doubleValue());</span>
			} else {
				// Do not allow numeric (left) and
				// string (right) to be evaluated together.
<span class="nc" id="L358">				throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
			}

<span class="nc" id="L361">			rtnResult = new Double(doubleResult).toString();</span>
<span class="nc" id="L362">		} else {</span>
<span class="nc" id="L363">			throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
		}

<span class="nc" id="L366">		return rtnResult;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>