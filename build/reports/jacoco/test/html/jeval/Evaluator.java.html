<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Evaluator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java8-projects</a> &gt; <a href="index.source.html" class="el_package">jeval</a> &gt; <span class="el_source">Evaluator.java</span></div><h1>Evaluator.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2007 Robert Breidecker.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jeval;

import com.aadavan.rule.execution.quickrule.check.FunctionArguments;
import jeval.function.*;
import jeval.function.math.MathFunctions;
import jeval.function.string.StringFunctions;
import jeval.operator.*;

import java.util.*;

/**
 * This class is used to evaluate mathematical, string, Boolean and functional
 * expressions. It is the main entry point into the JEval API.&lt;br&gt;
 * &lt;br&gt;
 * The following types of expressions are supported:&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;i&gt;mathematical&lt;/i&gt; Expression involving numbers. Numbers are treated
 * as doubles, so resulting numbers will contain at least one decimal place.&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;string&lt;/i&gt; String can also be added together, compared, etc...&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;Boolean&lt;/i&gt; Expression that evaluate to true (1.0) and false (0.0).&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;functional&lt;/i&gt; Custom functions can be created or there are many
 * Math and String functions that JEval supplies with this class.&lt;/li&gt;
 * &lt;/ul&gt;
 * The following operators are supported:&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;( open parentheses&lt;/li&gt;
 * &lt;li&gt;) closed parentheses&lt;/li&gt;
 * &lt;li&gt;+ addition (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;- subtraction&lt;/li&gt;
 * &lt;li&gt;* multiplication&lt;/li&gt;
 * &lt;li&gt;/ division&lt;/li&gt;
 * &lt;li&gt;% modulus&lt;/li&gt;
 * &lt;li&gt;+ unary plus&lt;/li&gt;
 * &lt;li&gt;- unary minus&lt;/li&gt;
 * &lt;li&gt;= equal (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;!= not equal (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;&lt; less than (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;&lt;= less than or equal (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;&gt; greater than (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;&gt;= greater than or equal (for numbers and strings)&lt;/li&gt;
 * &lt;li&gt;&amp;&amp; boolean and&lt;/li&gt;
 * &lt;li&gt;|| boolean or&lt;/li&gt;
 * &lt;li&gt;! boolean not&lt;/li&gt;
 * &lt;/ul&gt;
 * Allows for prebuilt and custom functions.&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;JEval already comes with many functions which represent most of the
 * methods in the Math and String classes in the standard JDK.&lt;/li&gt;
 * &lt;li&gt;Thirty-nine math and string functions come built in. See the
 * jeval.functions.math and
 * jeval.functions.string packages for details on these ready to
 * use functions. You can choose to not load these functions if we you want to
 * gain a small improvement in performance.&lt;/li&gt;
 * &lt;li&gt;Functions must be followed by an open parentheses and a closed
 * parentheses which contain any required parameters.&lt;/li&gt;
 * &lt;li&gt;For more details on functions, see the Function class and the test
 * classes.&lt;/li&gt;
 * &lt;/ul&gt;
 * Allows for variables.&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Variable must be enclosed by a pound sign and open brace #{ and a closed
 * brace }. i.e. expression = &quot;#{a} + #{b}&quot;&lt;/li&gt;
 * &lt;li&gt;Two math variables come built in. The E and PI variables represent the
 * same value as the Math.E and Math.PI constants in the standard Java SDK. You
 * can choose not to load these variables.&lt;/li&gt;
 * &lt;/ul&gt;
 * Notes on expression parsing:
 * &lt;ul&gt;
 * &lt;li&gt;Spaces are ignored when parsing expressions.&lt;/li&gt;
 * &lt;li&gt;The order of precedence used by this class is as follows from highest to
 * lowest.&lt;/li&gt;
 * &lt;li&gt;The expression is evaluated as one or more subexpressions.
 * Subexpressions within open parentheses and closed parentheses are evaluated
 * before other parts of the expression.&lt;/li&gt;
 * &lt;li&gt;Inner most subexpression are evaluated first working outward.&lt;/li&gt;
 * &lt;li&gt;Subexpressions at the same level are evaluated from left to right.&lt;/li&gt;
 * &lt;li&gt;When evaluating expressions and subexpressions, operators are evaluated
 * with the following precedence listed below.&lt;/li&gt;
 * &lt;li&gt;Operators with with the same precedence are evaluated from left to
 * right.&lt;/li&gt;
 * &lt;li&gt;Once the expression is parsed, Variables are replaced with their values.
 * The evaluator has its own internal variable map that it used to resolve
 * variable values. All of the variable related methods on the evaluator refer
 * to this internal map. You can choose to set you own variable resolver on your
 * evaluator instance. If you do this, then variables resolved by your resolver
 * will override any variables in the evaluator's internal variable map.&lt;/li&gt;
 * &lt;li&gt;Functions are then executed and replaced with their results. Function
 * arguments are each individually evaluated as subexpressions that are comma
 * separated. This gives you the ability to use nested functions in your
 * expressions. You can choose not to evaluate function arguments as expressions
 * and instead let the functions handle the arguments themselves. This in effect
 * turns off nested expressions, unless you code nested expression support into
 * your own custom functions.&lt;/li&gt;
 * &lt;li&gt;Once all variables and functions are resolved, then the parsed
 * expression and subexpressions are evaluated according to operator precedence.&lt;/li&gt;
 * &lt;/ul&gt;
 * Operator precedence:
 * &lt;ul&gt;
 * &lt;li&gt;+ unary plus, - unary minus, ! boolean not&lt;/li&gt;
 * &lt;li&gt;* multiplication, / division, % modulus&lt;/li&gt;
 * &lt;li&gt;+ addition, - subtraction&lt;/li&gt;
 * &lt;li&gt;&lt; less than, &lt;= less than or equal, &gt; greater than, &gt;= greater than or
 * equal&lt;/li&gt;
 * &lt;li&gt;= equal, != not equal&lt;/li&gt;
 * &lt;li&gt;&amp;&amp; boolean and&lt;/li&gt;
 * &lt;li&gt;|| boolean or&lt;/li&gt;
 * &lt;/ul&gt;
 * Function and variable names can not break any of the following rules:&lt;br&gt;
 * &lt;ul&gt;
 * &lt;li&gt;can not start with a number&lt;/li&gt;
 * &lt;li&gt;can not contain an operator (see the above list of operators)/li&gt;
 * &lt;li&gt;can not contain a quote character - single or double/li&gt;
 * &lt;li&gt;can not contain a brace character - open or closed/li&gt;
 * &lt;li&gt;can not contain one of the following special characters: #, ~ , ^ !&lt;/li&gt;
 * &lt;/ul&gt;
 * Other Notes:
 * &lt;ul&gt;
 * &lt;li&gt;This class is not thread safe.&lt;/li&gt;
 * &lt;li&gt;Allows for the quote character (single or double) to be specified at run
 * time. Quote characters are required for specifying string values.&lt;/li&gt;
 * &lt;li&gt;Expressions can contain different types of expressions within the same
 * expression. However, Numeric and string types can not be mixed in a left /
 * right operand pair.&lt;/li&gt;
 * &lt;li&gt;An expression can be parsed before being evaluated by calling the parse()
 * method. This may save on response time if parsing takes more than a few 
 * seconds. However, parsing is usually very fast, so this is probably not 
 * needed.&lt;/li&gt;
 * &lt;li&gt;If an expression does not change, it will not be parsed each
 * time the expression is evaluated. Therefore, variables values can change and
 * the expression can be evaluated again without having to re-parse the
 * expression.&lt;/li&gt;
 * &lt;li&gt;Nested functions calls are supported. Nested function support can be
 * turned off to improve performance. Custom functions can be coded to handle
 * nested calls instead if desired.&lt;/li&gt;
 * &lt;li&gt;The string used to start variables, &quot;#{&quot;, can not appear in an
 * expression.
 * &lt;li&gt;See the evaluate methods in this class, JUnit tests and samples for more
 * details.&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class Evaluator {

	// Contains all of the operators.
<span class="nc" id="L160">	private List operators = new ArrayList();</span>

	// Contains all of the functions in use.
<span class="nc" id="L163">	private Map functions = new HashMap();</span>

	// Contains all of the variables in use.
<span class="nc" id="L166">	private Map variables = new HashMap();</span>

	// The quote character in use.
<span class="nc" id="L169">	private char quoteCharacter = EvaluationConstants.SINGLE_QUOTE;</span>

	// The open parentheses operator.
<span class="nc" id="L172">	private Operator openParenthesesOperator = new OpenParenthesesOperator();</span>

	// The closed parentheses operator.
<span class="nc" id="L175">	private Operator closedParenthesesOperator = new ClosedParenthesesOperator();</span>

	// Indicates if the user wants to load the system math variables.
	private boolean loadMathVariables;

	// Indicates if the user wants to load the system math functions.
	private boolean loadMathFunctions;

	// Indicates if the user wants to load the system string functions.
	private boolean loadStringFunctions;
	
	// Indicates if the user wants to process nested function calls.
	private boolean processNestedFunctions;

	// Saves the previous expression, because we do not want to parse it, if
	// it did not change.
<span class="nc" id="L191">	private String previousExpression = null;</span>

	// The previous stack of parsed operators
<span class="nc" id="L194">	private Stack previousOperatorStack = null;</span>

	// The previous stack of parsed operands.
<span class="nc" id="L197">	private Stack previousOperandStack = null;</span>

	// The stack of parsed operators
<span class="nc" id="L200">	private Stack operatorStack = null;</span>

	// The stack of parsed operands.
<span class="nc" id="L203">	private Stack operandStack = null;</span>
	
	// Allows for user to set their own variable resolver.
<span class="nc" id="L206">	private VariableResolver variableResolver = null;</span>

	private FunctionArguments functionArguments;
	
	public FunctionArguments getFunctionArguments() {
<span class="nc" id="L211">		return functionArguments;</span>
	}

	public void setFunctionArguments(FunctionArguments functionArguments) {
<span class="nc" id="L215">		this.functionArguments = functionArguments;</span>
<span class="nc" id="L216">	}</span>
	
<span class="nc" id="L218">	private List&lt;String&gt; observationList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L219">	private Map&lt;String,Object&gt; observationData = new HashMap&lt;String,Object&gt;();</span>
	
	public Map&lt;String, Object&gt; getObservationData() {
<span class="nc" id="L222">		return observationData;</span>
	}

	public void emitData(String key, Object object) {
<span class="nc" id="L226">		this.observationData.put(key, object);</span>
<span class="nc" id="L227">	}</span>
	
	public void setObservationData(Map&lt;String, Object&gt; observationData) {
<span class="nc" id="L230">		this.observationData = observationData;</span>
<span class="nc" id="L231">	}</span>

	public List&lt;String&gt; getObservationList() {
<span class="nc" id="L234">		return observationList;</span>
	}

	public void updateObservation(String observation) {
<span class="nc" id="L238">		observationList.add(observation);</span>
<span class="nc" id="L239">	}</span>

	/**
	 * The default constructor. This constructor calls the five parameter
	 * Evaluator constructor and passes in the following default values:
	 * SINGLE_QUOTE, true, true, true and true.
	 */
	public Evaluator() {
<span class="nc" id="L247">		this(EvaluationConstants.SINGLE_QUOTE, true, true, true, true);</span>
<span class="nc" id="L248">	}</span>

	/**
	 * The main constructor for Evaluator.
	 * 
	 * @param quoteCharacter
	 *            The quote character to use when evaluating expression.
	 * @param loadMathVariables
	 *            Indicates if the standard Math variables should be loaded or
	 *            not.
	 * @param loadMathFunctions
	 *            Indicates if the standard Math functions should be loaded or
	 *            not.
	 * @param loadStringFunctions
	 *            Indicates if the standard String functions should be loaded or
	 *            not.
	 * @param processNestedFunctions
	 *            Indicates if nested function calls should be processed or not.
	 * 
	 * @exception IllegalArgumentException
	 *                Thrown when the quote character is not a valid quote
	 *                character.
	 */
	public Evaluator(final char quoteCharacter,
			final boolean loadMathVariables, final boolean loadMathFunctions,
			final boolean loadStringFunctions,
<span class="nc" id="L274">			final boolean processNestedFunctions) {</span>

		// Install the operators used by Evaluator.
<span class="nc" id="L277">		installOperators();</span>

		// Install the system variables.
<span class="nc" id="L280">		this.loadMathVariables = loadMathVariables;</span>
<span class="nc" id="L281">		loadSystemVariables();</span>

		// Install the system functions.
<span class="nc" id="L284">		this.loadMathFunctions = loadMathFunctions;</span>
<span class="nc" id="L285">		this.loadStringFunctions = loadStringFunctions;</span>
<span class="nc" id="L286">		loadSystemFunctions();</span>

		// Set the default quote character.
<span class="nc" id="L289">		setQuoteCharacter(quoteCharacter);</span>

		// Process nested function calls.
<span class="nc" id="L292">		this.processNestedFunctions = processNestedFunctions;</span>
<span class="nc" id="L293">	}</span>

	/**
	 * Returns the current quote character in use.
	 * 
	 * @return The quote character in use.
	 */
	public char getQuoteCharacter() {
<span class="nc" id="L301">		return quoteCharacter;</span>
	}

	/**
	 * Sets the quote character to use when evaluating expressions.
	 * 
	 * @param quoteCharacter
	 *            The quote character to use when evaluating expressions.
	 * 
	 * @exception IllegalArgumentException
	 *                Thrown when the quote character is not a valid quote
	 *                character.
	 */
	public void setQuoteCharacter(final char quoteCharacter) {
<span class="nc bnc" id="L315" title="All 4 branches missed.">		if (quoteCharacter == EvaluationConstants.SINGLE_QUOTE</span>
				|| quoteCharacter == EvaluationConstants.DOUBLE_QUOTE) {
<span class="nc" id="L317">			this.quoteCharacter = quoteCharacter;</span>
		} else {
<span class="nc" id="L319">			throw new IllegalArgumentException(&quot;Invalid quote character.&quot;);</span>
		}
<span class="nc" id="L321">	}</span>

	/**
	 * Adds a function to the list of functions to use when evaluating
	 * expressions.
	 * 
	 * @param function
	 *            The function being added.
	 * 
	 * @exception IllegalArgumentException
	 *                Thrown when the function name is not valid or the function
	 *                name is already in use.
	 */
	public void putFunction(final Function function) {
		// Make sure the function name is valid.
<span class="nc" id="L336">		isValidName(function.getName());</span>

		// Make sure the function name isn't already in use.
<span class="nc" id="L339">		final Function existingFunction = (Function) functions.get(function</span>
<span class="nc" id="L340">				.getName());</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (existingFunction == null) {</span>
<span class="nc" id="L343">			functions.put(function.getName(), function);</span>
		} else {
<span class="nc" id="L345">			throw new IllegalArgumentException(&quot;A function with the same name &quot;</span>
					+ &quot;already exists.&quot;);
		}
<span class="nc" id="L348">	}</span>

	/**
	 * Returns a funtion from the list of functions. If the function can not be
	 * found in the list of functions, then null will be returned.
	 * 
	 * @param functionName
	 *            The name of the function to retrieve the value for.
	 * 
	 * @return The value for a function in the list of function.
	 */
	public Function getFunction(final String functionName) {
<span class="nc" id="L360">		return (Function) functions.get(functionName);</span>
	}

	/**
	 * Removes the function from the list of functions to use when evaluating
	 * expressions.
	 * 
	 * @param functionName
	 *            The name of the function to remove.
	 */
	public void removeFunction(final String functionName) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">		if (functions.containsKey(functionName)) {</span>
<span class="nc" id="L372">			functions.remove(functionName);</span>
		} else {
<span class="nc" id="L374">			throw new IllegalArgumentException(&quot;The function does not exist.&quot;);</span>
		}
<span class="nc" id="L376">	}</span>

	/**
	 * Removes all of the functions at one time.
	 */
	public void clearFunctions() {
		// Remove all functions.
<span class="nc" id="L383">		functions.clear();</span>

		// Reload the system functions if necessary.
<span class="nc" id="L386">		loadSystemFunctions();</span>
<span class="nc" id="L387">	}</span>
	
	/**
	 * Rturns the map of functions currently set on this object.
	 * 
	 * @return the map of functions currently set on this object.
	 */
	public Map getFunctions() {
<span class="nc" id="L395">		return functions;</span>
	}
	
	/**
	 * Sets the map of functions for this object.
	 * 
	 * @param functions The map of functions for this object.
	 */
	public void setFunctions(Map functions) {
<span class="nc" id="L404">		this.functions = functions;</span>
<span class="nc" id="L405">	}</span>

	/**
	 * Adds or replaces a variable to the list of variables to use when
	 * evaluating expressions. If the variable already exists, then its value
	 * will be overlaid.
	 * 
	 * @param variableName
	 *            The name of the variable being set.
	 * @param variableValue
	 *            The value for the variable being set.
	 */
	public void putVariable(final String variableName,
			final String variableValue) {
		// Make sure the variable name is valid.
<span class="nc" id="L420">		isValidName(variableName);</span>

<span class="nc" id="L422">		variables.put(variableName, variableValue);</span>
<span class="nc" id="L423">	}</span>

    /**
	 * Returns the value for a variable in the list of variables. If the
	 * variable can not be found in the list of variables, then null will be
	 * returned.
	 * 
	 * @param variableName
	 *            The name of the variable to retrieve the value for.
	 * 
	 * @return The value for a variable in the list of variables.
	 * 
	 * @throws Throws
	 *             an EvaluatorException if the variable name can not be
	 *             resolved.
	 */
	public String getVariableValue(final String variableName)
			throws EvaluationException {

<span class="nc" id="L442">		String variableValue = null;</span>

		/*
		 * If the user has implemented a variable resolver and set it onto this
		 * object, then use it before looking in the variable map.
		 */
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (variableResolver != null) {</span>

			try {
<span class="nc" id="L451">				variableValue = variableResolver.resolveVariable(variableName);</span>
<span class="nc" id="L452">			} catch (FunctionException fe) {</span>
<span class="nc" id="L453">				throw new EvaluationException(fe.getMessage(), fe);</span>
<span class="nc" id="L454">			}</span>
		}

		/*
		 * If no variable value at this point, then go to the internal variable
		 * map to resolve the variable.
		 */
<span class="nc bnc" id="L461" title="All 2 branches missed.">		if (variableValue == null) {</span>

<span class="nc" id="L463">			variableValue = (String) variables.get(variableName);</span>
		}

<span class="nc bnc" id="L466" title="All 2 branches missed.">		if (variableValue == null) {</span>

<span class="nc" id="L468">			throw new EvaluationException(</span>
					&quot;Can not resolve variable with name equal to \&quot;&quot;
							+ variableName + &quot;\&quot;.&quot;);
		}

<span class="nc" id="L473">		return variableValue;</span>
	}

	/**
	 * Removes the variable from the list of variables to use when evaluating
	 * expressions.
	 * 
	 * @param variableName
	 *            The name of the variable to remove.
	 */
	public void removeVaraible(final String variableName) {
<span class="nc bnc" id="L484" title="All 2 branches missed.">		if (variables.containsKey(variableName)) {</span>
<span class="nc" id="L485">			variables.remove(variableName);</span>
		} else {
<span class="nc" id="L487">			throw new IllegalArgumentException(&quot;The variable does not exist.&quot;);</span>
		}
<span class="nc" id="L489">	}</span>

	/**
	 * Removes all of the variables at one time.
	 */
	public void clearVariables() {
		// Remove all functions.
<span class="nc" id="L496">		variables.clear();</span>

		// Reload the system variables if necessary.
<span class="nc" id="L499">		loadSystemVariables();</span>
<span class="nc" id="L500">	}</span>
	
	/**
	 * Rturns the map of variables currently set on this object.
	 * 
	 * @return the map of variables currently set on this object.
	 */
	public Map getVariables() {
<span class="nc" id="L508">		return variables;</span>
	}
	
	/**
	 * Sets the map of variables for this object.
	 * 
	 * @param variables The map of variables for this object.
	 */
	public void setVariables(Map variables) {
<span class="nc" id="L517">		this.variables = variables;</span>
<span class="nc" id="L518">	}	</span>
	
	/**
	 * Returns the variable resolver.  The variable resolver can be used by 
	 * the user to resolve their own variables.  Variables in the variable
	 * resolver override any variables that are in this classes internal
	 * variable map.
	 * 
	 * @return The variable resolver.
	 */
	public VariableResolver getVariableResolver() {
<span class="nc" id="L529">		return variableResolver;</span>
	}

	/**
	 * Sets the variable resolver for this class.  Varaibles resolved by the
	 * variable resolver will override any variables in this class's internal
	 * variable map.
	 * 
	 * @param variableResolver The variable resolver for this class.
	 */
	public void setVariableResolver(VariableResolver variableResolver) {
<span class="nc" id="L540">		this.variableResolver = variableResolver;</span>
<span class="nc" id="L541">	}</span>

	/**
	 * This method evaluates mathematical, boolean or functional expressions.
	 * See the class description and test classes for more information on how to
	 * write an expression. If quotes exist around a string expression, then
	 * they will be left in the result string. Function will also have their
	 * results wrapped with the appripriate quote characters.
	 * 
	 * @param expression
	 *            The expression to evaluate.
	 * 
	 * @return The result of the evaluated. expression. Numbers are treated as
	 *         doubles, so resulting numbers will contain at least one decimal
	 *         place.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression.
	 */
	public String evaluate(final String expression) throws EvaluationException {
<span class="nc" id="L562">		return evaluate(expression, true, true);</span>
	}

	/**
	 * This method evaluates mathematical, boolean or functional expressions.
	 * See the class description and test classes for more information on how to
	 * write an expression. The expression used will be the one previously
	 * specified when using the parse method. If the parse method has not been
	 * called before calling this method, then an exception will be thrown. If
	 * quotes exist around a string expression, then they will be left in the
	 * result string. Function will also have their results wrapped with the
	 * appropriate quote characters.
	 * 
	 * @return The result of the evaluated. expression. Numbers are treated as
	 *         doubles, so resulting numbers will contain at least one decimal
	 *         place.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression.
	 */
	public String evaluate() throws EvaluationException {
		// Get the previously parsed expression.
<span class="nc" id="L585">		final String expression = previousExpression;</span>

<span class="nc bnc" id="L587" title="All 4 branches missed.">		if (expression == null || expression.length() == 0) {</span>
<span class="nc" id="L588">			throw new EvaluationException(&quot;No expression has been specified.&quot;);</span>
		}

<span class="nc" id="L591">		return evaluate(expression, true, true);</span>
	}

	/**
	 * This method evaluates mathematical, boolean or functional expressions.
	 * See the class description and test classes for more information on how to
	 * write an expression.
	 * 
	 * @param expression
	 *            The expression to evaluate.
	 * @param keepQuotes
	 *            Indicates if the the quotes should be kept in the result or
	 *            not. This is only for string expression that are enclosed in
	 *            quotes prior to being evaluated.
	 * @param wrapStringFunctionResults
	 *            Indicates if the results from functions that return strings
	 *            should be wrapped in quotes. The quote character used will be
	 *            whatever is the current quote character for this object.
	 * 
	 * @return The result of the evaluated expression. Numbers are treated as
	 *         doubles, so resulting numbers will contain at least one decimal
	 *         place.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression.
	 */
	public String evaluate(final String expression, final boolean keepQuotes,
			final boolean wrapStringFunctionResults) throws EvaluationException {

		// Parse the expression.
<span class="nc" id="L622">		parse(expression);</span>

<span class="nc" id="L624">		String result = getResult(operatorStack, operandStack,</span>
				wrapStringFunctionResults);

		// Remove the quotes if necessary.
<span class="nc bnc" id="L628" title="All 4 branches missed.">		if (isExpressionString(result) &amp;&amp; !keepQuotes) {</span>
<span class="nc" id="L629">			result = result.substring(1, result.length() - 1);</span>
		}

<span class="nc" id="L632">		return result;</span>
	}

	/**
	 * This method evaluates mathematical, boolean or functional expressions.
	 * The expression used will be the one previously specified when using the
	 * parse method. If the parse method has not been called before calling this
	 * method, then an exception will be thrown. See the class description and
	 * test classes for more information on how to write an expression.
	 * 
	 * @param keepQuotes
	 *            Indicates if the the quotes should be kept in the result or
	 *            not. This is only for string expressions that are enclosed in
	 *            quotes prior to being evaluated.
	 * @param wrapStringFunctionResults
	 *            Indicates if the results from functions that return strings
	 *            should be wrapped in quotes. The quote character used will be
	 *            whatever is the current quote character for this object.
	 * 
	 * @return The result of the evaluated expression. Numbers are treated as
	 *         doubles, so resulting numbers will contain at least one decimal
	 *         place.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression.
	 */
	public String evaluate(final boolean keepQuotes,
			final boolean wrapStringFunctionResults) throws EvaluationException {

		// Get the previously parsed expression.
<span class="nc" id="L663">		final String expression = previousExpression;</span>

<span class="nc bnc" id="L665" title="All 4 branches missed.">		if (expression == null || expression.length() == 0) {</span>
<span class="nc" id="L666">			throw new EvaluationException(&quot;No expression has been specified.&quot;);</span>
		}

<span class="nc" id="L669">		return evaluate(expression, keepQuotes, wrapStringFunctionResults);</span>
	}

	/**
	 * This method is a simple wrapper around the evaluate(String) method. Its
	 * purpose is to return a more friendly boolean return value instead of the
	 * string &quot;1.0&quot; (for true) and &quot;0.0&quot; (for false) that is normally returned.
	 * 
	 * @param expression
	 *            The expression to evaluate.
	 * 
	 * @return A boolean value that represents the result of the evaluated
	 *         expression.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression. It is also thrown if the result is not able to
	 *                be converted to a boolean value.
	 */
	public boolean getBooleanResult(final String expression)
			throws EvaluationException {

<span class="nc" id="L691">		final String result = evaluate(expression);</span>

		try {
<span class="nc" id="L694">			Double doubleResult = new Double(result);</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">			if (doubleResult.doubleValue() == 1.0) {</span>
<span class="nc" id="L697">				return true;</span>
			}
<span class="nc" id="L699">		} catch (NumberFormatException exception) {</span>
<span class="nc" id="L700">			return false;</span>
<span class="nc" id="L701">		}</span>

<span class="nc" id="L703">		return false;</span>
	}

	/**
	 * This method is a simple wrapper around the evaluate(String) method. Its
	 * purpose is to return a more friendly double return value instead of the
	 * string number that is normally returned.
	 * 
	 * @param expression
	 *            The expression to evaluate.
	 * 
	 * @return A double value that represents the result of the evaluated
	 *         expression.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression. It is also thrown if the result is not able to
	 *                be converted to a double value.
	 */
	public double getNumberResult(final String expression)
			throws EvaluationException {

<span class="nc" id="L725">		final String result = evaluate(expression);</span>
<span class="nc" id="L726">		Double doubleResult = null;</span>

		try {
<span class="nc" id="L729">			doubleResult = new Double(result);</span>
<span class="nc" id="L730">		} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L731">			throw new EvaluationException(</span>
					&quot;Expression does not produce a number.&quot;, nfe);
<span class="nc" id="L733">		}</span>

<span class="nc" id="L735">		return doubleResult.doubleValue();</span>
	}

	/**
	 * This method parses a mathematical, boolean or functional expressions.
	 * When the expression is eventually evaluated, as long as the expression
	 * has not changed, it will not have to be reparsed. See the class
	 * description and test classes for more information on how to write an
	 * expression.
	 * 
	 * @param expression
	 *            The expression to evaluate.
	 * 
	 * @exception EvaluateException
	 *                Thrown when an error is found while evaluating the
	 *                expression.
	 */
	public void parse(final String expression) throws EvaluationException {

		// Save the expression.
<span class="nc" id="L755">		boolean parse = true;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">		if (!expression.equals(previousExpression)) {</span>
<span class="nc" id="L757">			previousExpression = expression;</span>
		} else {
<span class="nc" id="L759">			parse = false;</span>
<span class="nc" id="L760">			operatorStack = (Stack) previousOperatorStack.clone();</span>
<span class="nc" id="L761">			operandStack = (Stack) previousOperandStack.clone();</span>
		}

		try {
<span class="nc bnc" id="L765" title="All 2 branches missed.">			if (parse) {</span>
				// These stacks will keep track of the operands and operators.
<span class="nc" id="L767">				operandStack = new Stack();</span>
<span class="nc" id="L768">				operatorStack = new Stack();</span>

				// Flags to help us keep track of what we are processing.
<span class="nc" id="L771">				boolean haveOperand = false;</span>
<span class="nc" id="L772">				boolean haveOperator = false;</span>
<span class="nc" id="L773">				Operator unaryOperator = null;</span>

				// We are going to process until we get to the end, so get the
				// length.
<span class="nc" id="L777">				int numChars = expression.length();</span>
<span class="nc" id="L778">				int charCtr = 0;</span>

				// Process until the counter exceeds the length. The goal is to
				// get
				// all of the operands and operators.
<span class="nc bnc" id="L783" title="All 2 branches missed.">				while (charCtr &lt; numChars) {</span>
<span class="nc" id="L784">					Operator operator = null;</span>
<span class="nc" id="L785">					int operatorIndex = -1;</span>

					// Skip any white space.
<span class="nc bnc" id="L788" title="All 2 branches missed.">					if (EvaluationHelper.isSpace(expression.charAt(charCtr))) {</span>
<span class="nc" id="L789">						charCtr++;</span>
<span class="nc" id="L790">						continue;</span>
					}

					// Get the next operator.
<span class="nc" id="L794">					NextOperator nextOperator = getNextOperator(expression,</span>
							charCtr, null);

<span class="nc bnc" id="L797" title="All 2 branches missed.">					if (nextOperator != null) {</span>
<span class="nc" id="L798">						operator = nextOperator.getOperator();</span>
<span class="nc" id="L799">						operatorIndex = nextOperator.getIndex();</span>
					}

					// Check if it is time to process an operand.
<span class="nc bnc" id="L803" title="All 4 branches missed.">					if (operatorIndex &gt; charCtr || operatorIndex == -1) {</span>
<span class="nc" id="L804">						charCtr = processOperand(expression, charCtr,</span>
								operatorIndex, operandStack, unaryOperator);

<span class="nc" id="L807">						haveOperand = true;</span>
<span class="nc" id="L808">						haveOperator = false;</span>
<span class="nc" id="L809">						unaryOperator = null;</span>
					}

					// Check if it is time to process an operator.
<span class="nc bnc" id="L813" title="All 2 branches missed.">					if (operatorIndex == charCtr) {</span>
<span class="nc bnc" id="L814" title="All 6 branches missed.">						if (nextOperator.getOperator().isUnary()</span>
								&amp;&amp; (haveOperator || charCtr == 0)) {
<span class="nc" id="L816">							charCtr = processUnaryOperator(operatorIndex,</span>
<span class="nc" id="L817">									nextOperator.getOperator());</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">							if (unaryOperator == null) {</span>
								// We have an unary operator.
<span class="nc" id="L821">								unaryOperator = nextOperator.getOperator();</span>
							} else {
<span class="nc" id="L823">								throw new EvaluationException(</span>
										&quot;Consecutive unary &quot;
												+ &quot;operators are not allowed (index=&quot;
												+ charCtr + &quot;).&quot;);
							}
						} else {
<span class="nc" id="L829">							charCtr = processOperator(expression,</span>
									operatorIndex, operator, operatorStack,
									operandStack, haveOperand, unaryOperator);

<span class="nc" id="L833">							unaryOperator = null;</span>
						}

<span class="nc bnc" id="L836" title="All 2 branches missed.">						if (!(nextOperator.getOperator() instanceof ClosedParenthesesOperator)) {</span>
<span class="nc" id="L837">							haveOperand = false;</span>
<span class="nc" id="L838">							haveOperator = true;</span>
						}
					}
<span class="nc" id="L841">				}</span>

				// Save the parsed operators and operands.
<span class="nc" id="L844">				previousOperatorStack = (Stack) operatorStack.clone();</span>
<span class="nc" id="L845">				previousOperandStack = (Stack) operandStack.clone();</span>
			}
<span class="nc" id="L847">		} catch (Exception e) {</span>
			// Clear the previous expression, because it is invalid.
<span class="nc" id="L849">			previousExpression = &quot;&quot;;</span>

<span class="nc" id="L851">			throw new EvaluationException(e.getMessage(), e);</span>
<span class="nc" id="L852">		}</span>
<span class="nc" id="L853">	}</span>

	/**
	 * Install all of the operators into the list of operators to use when
	 * evaluating expressions.
	 */
	private void installOperators() {
		// Install the most used operators first.
<span class="nc" id="L861">		operators.add(openParenthesesOperator);</span>
<span class="nc" id="L862">		operators.add(closedParenthesesOperator);</span>
<span class="nc" id="L863">		operators.add(new AdditionOperator());</span>
<span class="nc" id="L864">		operators.add(new SubtractionOperator());</span>
<span class="nc" id="L865">		operators.add(new MultiplicationOperator());</span>
<span class="nc" id="L866">		operators.add(new DivisionOperator());</span>
<span class="nc" id="L867">		operators.add(new EqualOperator());</span>
<span class="nc" id="L868">		operators.add(new NotEqualOperator());</span>

		// If there is a first character conflict between two operators,
		// then install the operator with the greatest length first.
<span class="nc" id="L872">		operators.add(new LessThanOrEqualOperator()); // Length of 2.</span>
<span class="nc" id="L873">		operators.add(new LessThanOperator()); // Length of 1.</span>
<span class="nc" id="L874">		operators.add(new GreaterThanOrEqualOperator()); // Length of 2.</span>
<span class="nc" id="L875">		operators.add(new GreaterThanOperator()); // Length of 1.</span>

		// Install the least used operators last.
<span class="nc" id="L878">		operators.add(new BooleanAndOperator());</span>
<span class="nc" id="L879">		operators.add(new BooleanOrOperator());</span>
<span class="nc" id="L880">		operators.add(new BooleanNotOperator());</span>
<span class="nc" id="L881">		operators.add(new ModulusOperator());</span>
<span class="nc" id="L882">	}</span>

	/**
	 * Processes the operand that has been found in the expression.
	 * 
	 * @param expression
	 *            The expression being evaluated.
	 * @param operatorIndex
	 *            The position in the expression where the current operator
	 *            being processed is located.
	 * @param operandStack
	 *            The stack of operands.
	 * @param unaryOperator
	 *            The unary operator if we are working with one.
	 * 
	 * @return The new position in the expression where processing should
	 *         continue.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encoutnered while processing the
	 *                expression.
	 */
	private int processOperand(final String expression, final int charCtr,
			final int operatorIndex, final Stack operandStack,
			final Operator unaryOperator) throws EvaluationException {

<span class="nc" id="L908">		String operandString = null;</span>
<span class="nc" id="L909">		int rtnCtr = -1;</span>

		// Get the operand to process.
<span class="nc bnc" id="L912" title="All 2 branches missed.">		if (operatorIndex == -1) {</span>
<span class="nc" id="L913">			operandString = expression.substring(charCtr).trim();</span>
<span class="nc" id="L914">			rtnCtr = expression.length();</span>
		} else {
<span class="nc" id="L916">			operandString = expression.substring(charCtr, operatorIndex).trim();</span>
<span class="nc" id="L917">			rtnCtr = operatorIndex;</span>
		}

<span class="nc bnc" id="L920" title="All 2 branches missed.">		if (operandString.length() == 0) {</span>
<span class="nc" id="L921">			throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
		}

<span class="nc" id="L924">		final ExpressionOperand operand = new ExpressionOperand(operandString,</span>
				unaryOperator);
<span class="nc" id="L926">		operandStack.push(operand);</span>

<span class="nc" id="L928">		return rtnCtr;</span>
	}

	/**
	 * Processes the operator that has been found in the expression.
	 * 
	 * @param expression
	 *            The expression being evaluated.
	 * @param operatorIndex
	 *            The position in the expression where the current operator
	 *            being processed is located.
	 * @param operator
	 *            The operator being processed.
	 * @param operatorStack
	 *            The stack of operators.
	 * @param operandStack
	 *            The stack of operands.
	 * @param haveOperand
	 *            Indicates if have an operand to process.
	 * @param unaryOperator
	 *            The unary operand associated with thi operator. This may be
	 *            null.
	 * 
	 * @return The new position in the expression where processing should
	 *         continue.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encoutnered while processing the
	 *                expression.
	 */
	private int processOperator(final String expression,
			final int originalOperatorIndex, final Operator originalOperator,
			final Stack operatorStack, final Stack operandStack,
			final boolean haveOperand, final Operator unaryOperator)
			throws EvaluationException {

<span class="nc" id="L964">		int operatorIndex = originalOperatorIndex;</span>
<span class="nc" id="L965">		Operator operator = originalOperator;</span>

		// If we have and operand and the current operator is an instance
		// of OpenParenthesesOperator, then we are ready to process a function.
<span class="nc bnc" id="L969" title="All 4 branches missed.">		if (haveOperand &amp;&amp; operator instanceof OpenParenthesesOperator) {</span>
<span class="nc" id="L970">			NextOperator nextOperator = processFunction(expression,</span>
					operatorIndex, operandStack);

<span class="nc" id="L973">			operator = nextOperator.getOperator();</span>
<span class="nc" id="L974">			operatorIndex = nextOperator.getIndex() + operator.getLength();</span>

<span class="nc" id="L976">			nextOperator = getNextOperator(expression, operatorIndex, null);</span>

			// Look to see if there is another operator.
			// If there is, the process it, else get out of this routine.
<span class="nc bnc" id="L980" title="All 2 branches missed.">			if (nextOperator != null) {</span>
<span class="nc" id="L981">				operator = nextOperator.getOperator();</span>
<span class="nc" id="L982">				operatorIndex = nextOperator.getIndex();</span>
			} else {
<span class="nc" id="L984">				return operatorIndex;</span>
			}
		}

		// Determine what type of operator we are left with and process
		// accordingly.
<span class="nc bnc" id="L990" title="All 2 branches missed.">		if (operator instanceof OpenParenthesesOperator) {</span>
<span class="nc" id="L991">			final ExpressionOperator expressionOperator = new ExpressionOperator(</span>
					operator, unaryOperator);
<span class="nc" id="L993">			operatorStack.push(expressionOperator);</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">		} else if (operator instanceof ClosedParenthesesOperator) {</span>
<span class="nc" id="L995">			ExpressionOperator stackOperator = null;</span>

<span class="nc bnc" id="L997" title="All 2 branches missed.">			if (operatorStack.size() &gt; 0) {</span>
<span class="nc" id="L998">				stackOperator = (ExpressionOperator) operatorStack.peek();</span>
			}

			// Process until we reach an open parentheses.
<span class="nc bnc" id="L1002" title="All 2 branches missed.">			while (stackOperator != null</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">					&amp;&amp; !(stackOperator.getOperator() instanceof OpenParenthesesOperator)) {</span>
<span class="nc" id="L1004">				processTree(operandStack, operatorStack);</span>

<span class="nc bnc" id="L1006" title="All 2 branches missed.">				if (operatorStack.size() &gt; 0) {</span>
<span class="nc" id="L1007">					stackOperator = (ExpressionOperator) operatorStack.peek();</span>
				} else {
<span class="nc" id="L1009">					stackOperator = null;</span>
				}
			}

<span class="nc bnc" id="L1013" title="All 2 branches missed.">			if (operatorStack.isEmpty()) {</span>
<span class="nc" id="L1014">				throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
			}

			// Pop the open parameter from the stack.
<span class="nc" id="L1018">			final ExpressionOperator expressionOperator = (ExpressionOperator) operatorStack</span>
<span class="nc" id="L1019">					.pop();</span>

<span class="nc bnc" id="L1021" title="All 2 branches missed.">			if (!(expressionOperator.getOperator() instanceof OpenParenthesesOperator)) {</span>
<span class="nc" id="L1022">				throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
			}

			// Process the unary operator if we have one.
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			if (expressionOperator.getUnaryOperator() != null) {</span>
<span class="nc" id="L1027">				Object operand = operandStack.pop();</span>

<span class="nc" id="L1029">				ExpressionTree tree = new ExpressionTree(this, operand, null,</span>
<span class="nc" id="L1030">						null, expressionOperator.getUnaryOperator());</span>

<span class="nc" id="L1032">				operandStack.push(tree);</span>
			}
<span class="nc" id="L1034">		} else {</span>
			// Process non-param operator.
<span class="nc bnc" id="L1036" title="All 2 branches missed.">			if (operatorStack.size() &gt; 0) {</span>
<span class="nc" id="L1037">				ExpressionOperator stackOperator = (ExpressionOperator) operatorStack</span>
<span class="nc" id="L1038">						.peek();</span>

<span class="nc bnc" id="L1040" title="All 2 branches missed.">				while (stackOperator != null</span>
<span class="nc" id="L1041">						&amp;&amp; stackOperator.getOperator().getPrecedence() &gt;= operator</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">								.getPrecedence()) {</span>
<span class="nc" id="L1043">					processTree(operandStack, operatorStack);</span>

<span class="nc bnc" id="L1045" title="All 2 branches missed.">					if (operatorStack.size() &gt; 0) {</span>
<span class="nc" id="L1046">						stackOperator = (ExpressionOperator) operatorStack</span>
<span class="nc" id="L1047">								.peek();</span>
					} else {
<span class="nc" id="L1049">						stackOperator = null;</span>
					}
				}
			}

<span class="nc" id="L1054">			ExpressionOperator expressionOperator = new ExpressionOperator(</span>
					operator, unaryOperator);

<span class="nc" id="L1057">			operatorStack.push(expressionOperator);</span>
		}

<span class="nc" id="L1060">		final int rtnCtr = operatorIndex + operator.getLength();</span>

<span class="nc" id="L1062">		return rtnCtr;</span>
	}

	/**
	 * Processes the unary operator that has been found in the expression.
	 * 
	 * @param operatorIndex
	 *            The position in the expression where the current operator
	 *            being processed is located.
	 * @param operator
	 *            The operator being processed.
	 * 
	 * @return The new position in the expression where processing should
	 *         continue.
	 */
	private int processUnaryOperator(final int operatorIndex,
			final Operator operator) {

<span class="nc" id="L1080">		final int rtnCtr = operatorIndex + operator.getSymbol().length();</span>

<span class="nc" id="L1082">		return rtnCtr;</span>
	}

	/**
	 * Processes the function that has been found in the expression.
	 * 
	 * @param expression
	 *            The expression being evaluated.
	 * @param operatorIndex
	 *            The position in the expression where the current operator
	 *            being processed is located.
	 * @param operandStack
	 *            The stack of operands.
	 * @param operatorStack
	 *            The stack of operators.
	 * @param operator
	 *            The current operator being processed.
	 * @param unaryOperator
	 *            The unary operator associated with this function. This can be
	 *            null.
	 * 
	 * @return The next operator in the expression. This should be the closed
	 *         parentheses operator.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encoutnered while processing the
	 *                expression.
	 */
	private NextOperator processFunction(final String expression,
			final int operatorIndex, final Stack operandStack)
			throws EvaluationException {

<span class="nc" id="L1114">		int parenthesisCount = 1;</span>
<span class="nc" id="L1115">		NextOperator nextOperator = null;</span>
<span class="nc" id="L1116">		int nextOperatorIndex = operatorIndex;</span>

		// Loop until we find the function's closing parentheses.
<span class="nc bnc" id="L1119" title="All 2 branches missed.">		while (parenthesisCount &gt; 0) {</span>
<span class="nc" id="L1120">			nextOperator = getNextOperator(expression, nextOperatorIndex + 1,</span>
					null);

<span class="nc bnc" id="L1123" title="All 2 branches missed.">			if (nextOperator == null) {</span>
<span class="nc" id="L1124">				throw new EvaluationException(&quot;Function is not closed.&quot;);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">			} else if (nextOperator.getOperator() instanceof OpenParenthesesOperator) {</span>
<span class="nc" id="L1126">				parenthesisCount++;</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">			} else if (nextOperator.getOperator() instanceof ClosedParenthesesOperator) {</span>
<span class="nc" id="L1128">				parenthesisCount--;</span>
			}

			// Get the next operator index.
<span class="nc" id="L1132">			nextOperatorIndex = nextOperator.getIndex();</span>
		}

		// Get the function argument.
<span class="nc" id="L1136">		String arguments = expression.substring(operatorIndex + 1,</span>
				nextOperatorIndex);

		// Pop the function name from the stack.
<span class="nc" id="L1140">		final ExpressionOperand operand = (ExpressionOperand) operandStack</span>
<span class="nc" id="L1141">				.pop();</span>
<span class="nc" id="L1142">		final Operator unaryOperator = operand.getUnaryOperator();</span>
<span class="nc" id="L1143">		final String functionName = operand.getValue();</span>

		// Validate that the function name is valid.
		try {
<span class="nc" id="L1147">			isValidName(functionName);</span>
<span class="nc" id="L1148">		} catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L1149">			throw new EvaluationException(&quot;Invalid function name of \&quot;&quot;</span>
					+ functionName + &quot;\&quot;.&quot;, iae);
<span class="nc" id="L1151">		}</span>

		// Get the function object.
<span class="nc" id="L1154">		final Function function = (Function) functions.get(functionName);</span>

<span class="nc bnc" id="L1156" title="All 2 branches missed.">		if (function == null) {</span>
<span class="nc" id="L1157">			throw new EvaluationException(&quot;A function is not defined (index=&quot;</span>
					+ operatorIndex + &quot;).&quot;);
		}

<span class="nc" id="L1161">		final ParsedFunction parsedFunction = new ParsedFunction(function,</span>
				arguments, unaryOperator);
<span class="nc" id="L1163">		operandStack.push(parsedFunction);</span>

<span class="nc" id="L1165">		return nextOperator;</span>
	}

	/**
	 * Processes an expresssion tree that has been parsed into an operand stack
	 * and oeprator stack.
	 * 
	 * @param operandStack
	 *            The stack of operands.
	 * @param operatorStack
	 *            The stack of operators.
	 */
	private void processTree(final Stack operandStack, final Stack operatorStack) {

<span class="nc" id="L1179">		Object rightOperand = null;</span>
<span class="nc" id="L1180">		Object leftOperand = null;</span>
<span class="nc" id="L1181">		Operator operator = null;</span>

		// Get the right operand node from the tree.
<span class="nc bnc" id="L1184" title="All 2 branches missed.">		if (operandStack.size() &gt; 0) {</span>
<span class="nc" id="L1185">			rightOperand = operandStack.pop();</span>
		}

		// Get the left operand node from the tree.
<span class="nc bnc" id="L1189" title="All 2 branches missed.">		if (operandStack.size() &gt; 0) {</span>
<span class="nc" id="L1190">			leftOperand = operandStack.pop();</span>
		}

		// Get the operator node from the tree.
<span class="nc" id="L1194">		operator = ((ExpressionOperator) operatorStack.pop()).getOperator();</span>

		// Build an expressin tree from the nodes.
<span class="nc" id="L1197">		final ExpressionTree tree = new ExpressionTree(this, leftOperand,</span>
				rightOperand, operator, null);

		// Push the tree onto the stack.
<span class="nc" id="L1201">		operandStack.push(tree);</span>
<span class="nc" id="L1202">	}</span>

	/**
	 * Returns the final result of the evaluated expression.
	 * 
	 * @param operatorStack
	 *            The stack of operators.
	 * @param operandStack
	 *            The stack of operands.
	 * @param wrapStringFunctionResults
	 *            Indicates if the results from functions that return strings
	 *            should be wrapped in quotes. The quote character used will be
	 *            whatever is the current quote character for this object.
	 * 
	 * @return The final result of the evaluated expression.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encoutnered while processing the
	 *                expression.
	 */
	private String getResult(final Stack operatorStack,
			final Stack operandStack, final boolean wrapStringFunctionResults)
			throws EvaluationException {

		// The result to return.
<span class="nc" id="L1227">		String resultString = null;</span>

		// Process the rest of the operators left on the stack.
<span class="nc bnc" id="L1230" title="All 2 branches missed.">		while (operatorStack.size() &gt; 0) {</span>
<span class="nc" id="L1231">			processTree(operandStack, operatorStack);</span>
		}

		// At this point only one operand should be left on the tree.
		// It may be a tree operand that contains other tree and/or
		// other operands.
<span class="nc bnc" id="L1237" title="All 2 branches missed.">		if (operandStack.size() != 1) {</span>
<span class="nc" id="L1238">			throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
		}

<span class="nc" id="L1241">		final Object finalOperand = operandStack.pop();</span>

		// Check if the final operand is a tree.
<span class="nc bnc" id="L1244" title="All 2 branches missed.">		if (finalOperand instanceof ExpressionTree) {</span>
			// Get the final result.
<span class="nc" id="L1246">			resultString = ((ExpressionTree) finalOperand)</span>
<span class="nc" id="L1247">					.evaluate(wrapStringFunctionResults);</span>
		}
		// Check if the final operand is an operand.
<span class="nc bnc" id="L1250" title="All 2 branches missed.">		else if (finalOperand instanceof ExpressionOperand) {</span>
<span class="nc" id="L1251">			ExpressionOperand resultExpressionOperand = (ExpressionOperand) finalOperand;</span>

<span class="nc" id="L1253">			resultString = ((ExpressionOperand) finalOperand).getValue();</span>
<span class="nc" id="L1254">			resultString = replaceVariables(resultString);</span>

			// Check if the operand is a string or not. If it not a string,
			// then it must be a number.
<span class="nc bnc" id="L1258" title="All 2 branches missed.">			if (!isExpressionString(resultString)) {</span>
<span class="nc" id="L1259">				Double resultDouble = null;</span>
				try {
<span class="nc" id="L1261">					resultDouble = new Double(resultString);</span>
<span class="nc" id="L1262">				} catch (Exception e) {</span>
<span class="nc" id="L1263">					throw new EvaluationException(&quot;Expression is invalid.&quot;, e);</span>
<span class="nc" id="L1264">				}</span>

				// Process a unary operator if one exists.
<span class="nc bnc" id="L1267" title="All 2 branches missed.">				if (resultExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L1268">					resultDouble = new Double(resultExpressionOperand</span>
<span class="nc" id="L1269">							.getUnaryOperator().evaluate(</span>
<span class="nc" id="L1270">									resultDouble.doubleValue()));</span>
				}

				// Get the final result.
<span class="nc" id="L1274">				resultString = resultDouble.toString();</span>
<span class="nc" id="L1275">			} else {</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">				if (resultExpressionOperand.getUnaryOperator() != null) {</span>
<span class="nc" id="L1277">					throw new EvaluationException(&quot;Invalid operand for &quot;</span>
							+ &quot;unary operator.&quot;);
				}
			}
<span class="nc bnc" id="L1281" title="All 2 branches missed.">		} else if (finalOperand instanceof ParsedFunction) {</span>
<span class="nc" id="L1282">			final ParsedFunction parsedFunction = (ParsedFunction) finalOperand;</span>
<span class="nc" id="L1283">			final Function function = parsedFunction.getFunction();</span>
<span class="nc" id="L1284">			String arguments = parsedFunction.getArguments();</span>
			
<span class="nc bnc" id="L1286" title="All 2 branches missed.">			if (processNestedFunctions) {</span>
<span class="nc" id="L1287">				arguments = processNestedFunctions(arguments);</span>
			}
			
<span class="nc" id="L1290">			arguments = replaceVariables(arguments);</span>

			// Get the final result.
			try {				
<span class="nc" id="L1294">				FunctionResult functionResult = </span>
<span class="nc" id="L1295">					function.execute(this, arguments);</span>
<span class="nc" id="L1296">				resultString = functionResult.getResult();</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">				if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_NUMERIC) {
					
<span class="nc" id="L1301">					Double resultDouble = new Double(resultString);</span>

					// Process a unary operator if one exists.
<span class="nc bnc" id="L1304" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L1305">						resultDouble = new Double(parsedFunction</span>
<span class="nc" id="L1306">								.getUnaryOperator().evaluate(</span>
<span class="nc" id="L1307">										resultDouble.doubleValue()));</span>
					}

					// Get the final result.
<span class="nc" id="L1311">					resultString = resultDouble.toString();</span>
<span class="nc" id="L1312">				} </span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">				else if (functionResult.getType() == </span>
					FunctionConstants.FUNCTION_RESULT_TYPE_STRING) {
					
					// The result must be a string result.
<span class="nc bnc" id="L1317" title="All 2 branches missed.">					if (wrapStringFunctionResults) {</span>
<span class="nc" id="L1318">						resultString = quoteCharacter + resultString</span>
								+ quoteCharacter;
					}

<span class="nc bnc" id="L1322" title="All 2 branches missed.">					if (parsedFunction.getUnaryOperator() != null) {</span>
<span class="nc" id="L1323">						throw new EvaluationException(&quot;Invalid operand for &quot;</span>
								+ &quot;unary operator.&quot;);
					}
				}
<span class="nc" id="L1327">			} catch (FunctionException fe) {</span>
<span class="nc" id="L1328">				throw new EvaluationException(fe.getMessage(), fe);</span>
<span class="nc" id="L1329">			}</span>
<span class="nc" id="L1330">		} else {</span>
<span class="nc" id="L1331">			throw new EvaluationException(&quot;Expression is invalid.&quot;);</span>
		}

<span class="nc" id="L1334">		return resultString;</span>
	}

	/**
	 * Returns the next operator in the expression.
	 * 
	 * @param expression
	 *            The expression being evaluated.
	 * @param start
	 *            The position in the expression to start searching for the next
	 *            operator.
	 * @param match
	 *            The operator to search for. This can be null if you want the
	 *            very next operator. If it is not null, it searches until it
	 *            finds the match.
	 * 
	 * @return The next operator in the expression. Returns null if no next
	 *         operator is returned.
	 */
	private NextOperator getNextOperator(final String expression,
			final int start, final Operator match) {

<span class="nc" id="L1356">		final int numChars = expression.length();</span>
<span class="nc" id="L1357">		int numQuoteCharacters = 0;</span>

<span class="nc bnc" id="L1359" title="All 2 branches missed.">		for (int charCtr = start; charCtr &lt; numChars; charCtr++) {</span>
			// Keep track of open strings.
<span class="nc bnc" id="L1361" title="All 2 branches missed.">			if (expression.charAt(charCtr) == quoteCharacter) {</span>
<span class="nc" id="L1362">				numQuoteCharacters++;</span>
			}

			// Do not look into open strings.
<span class="nc bnc" id="L1366" title="All 2 branches missed.">			if ((numQuoteCharacters % 2) == 1) {</span>
<span class="nc" id="L1367">				continue;</span>
			}

			// Assumes the operators are installed in order of length.
<span class="nc" id="L1371">			final int numOperators = operators.size();</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">			for (int operatorCtr = 0; operatorCtr &lt; numOperators; operatorCtr++) {</span>
<span class="nc" id="L1373">				Operator operator = (Operator) operators.get(operatorCtr);</span>

<span class="nc bnc" id="L1375" title="All 2 branches missed.">				if (match != null) {</span>
					// Look through the operators until we find the
					// one we are searching for.
<span class="nc bnc" id="L1378" title="All 2 branches missed.">					if (!match.equals(operator)) {</span>
<span class="nc" id="L1379">						continue;</span>
					}
				}

				// The operator can 1 or 2 characters in length.
<span class="nc bnc" id="L1384" title="All 2 branches missed.">				if (operator.getLength() == 2) {</span>
<span class="nc" id="L1385">					int endCtr = -1;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">					if (charCtr + 2 &lt;= expression.length()) {</span>
<span class="nc" id="L1387">						endCtr = charCtr + 2;</span>
					} else {
<span class="nc" id="L1389">						endCtr = expression.length();</span>
					}

					// Look for a match.
<span class="nc bnc" id="L1393" title="All 2 branches missed.">					if (expression.substring(charCtr, endCtr).equals(</span>
<span class="nc" id="L1394">							operator.getSymbol())) {</span>
<span class="nc" id="L1395">						NextOperator nextOperator = new NextOperator(operator,</span>
								charCtr);

<span class="nc" id="L1398">						return nextOperator;</span>
					}
<span class="nc" id="L1400">				} else {</span>
					// Look for a match.
<span class="nc" id="L1402">					if (expression.charAt(charCtr) == operator.getSymbol()</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">							.charAt(0)) {</span>
<span class="nc" id="L1404">						NextOperator nextOperator = new NextOperator(operator,</span>
								charCtr);

<span class="nc" id="L1407">						return nextOperator;</span>
					}
				}
			}
		}

<span class="nc" id="L1413">		return null;</span>
	}

	/**
	 * Determines if the string represents a valid expression string or not.
	 * Valid expression strings must start and end with a quote character.
	 * 
	 * @param expressionString
	 *            The string being evaluated.
	 * 
	 * @return True if the string is a valid string and false if not.
	 */
	protected boolean isExpressionString(final String expressionString)
			throws EvaluationException {

<span class="nc bnc" id="L1428" title="All 2 branches missed.">		if (expressionString.length() &gt; 1</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">				&amp;&amp; expressionString.charAt(0) == quoteCharacter</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">				&amp;&amp; expressionString.charAt(expressionString.length() - 1) == quoteCharacter) {</span>
<span class="nc" id="L1431">			return true;</span>
		}

<span class="nc bnc" id="L1434" title="All 2 branches missed.">		if (expressionString.indexOf(quoteCharacter) &gt;= 0) {</span>
<span class="nc" id="L1435">			throw new EvaluationException(&quot;Invalid use of quotes.&quot;);</span>
		}

<span class="nc" id="L1438">		return false;</span>
	}

	/**
	 * This method verifies if a function or variable name is valid or not.
	 * 
	 * Function and variable names must follow these rules...
	 * &lt;ul&gt;
	 * &lt;li&gt;can not start with a number&lt;/li&gt;
	 * &lt;li&gt;can not contain an operator (see the above list of operators)&lt;/li&gt;
	 * &lt;li&gt;can not contain a quote character - single or double&lt;/li&gt;
	 * &lt;li&gt;can not contain a brace character - open or closed&lt;/li&gt;
	 * &lt;li&gt;can not contain one of the following special characters: #, ~ , ^ !&lt;/li&gt;
	 * &lt;ul&gt;
	 * 
	 * @param name
	 *            The function or variable name being validated.
	 * 
	 * @exception IllegalArgumentException
	 *                Thrown if the name is invalid.
	 */
	public void isValidName(final String name) throws IllegalArgumentException {

<span class="nc bnc" id="L1461" title="All 2 branches missed.">		if (name.length() == 0) {</span>
<span class="nc" id="L1462">			throw new IllegalArgumentException(&quot;Variable is empty.&quot;);</span>
		}

		// Check if name starts with a number.
<span class="nc" id="L1466">		final char firstChar = name.charAt(0);</span>
<span class="nc bnc" id="L1467" title="All 4 branches missed.">		if (firstChar &gt;= '0' &amp;&amp; firstChar &lt;= '9') {</span>
<span class="nc" id="L1468">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not start with a number.&quot;);
		}

		// Check if name contains with a quote character.
<span class="nc bnc" id="L1473" title="All 2 branches missed.">		if (name.indexOf(EvaluationConstants.SINGLE_QUOTE) &gt; -1) {</span>
<span class="nc" id="L1474">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a quote character.&quot;);
<span class="nc bnc" id="L1476" title="All 2 branches missed.">		} else if (name.indexOf(EvaluationConstants.DOUBLE_QUOTE) &gt; -1) {</span>
<span class="nc" id="L1477">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a quote character.&quot;);
		}

		// Check if name contains with a brace character.
<span class="nc bnc" id="L1482" title="All 2 branches missed.">		if (name.indexOf(EvaluationConstants.OPEN_BRACE) &gt; -1) {</span>
<span class="nc" id="L1483">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain an open brace character.&quot;);
<span class="nc bnc" id="L1485" title="All 2 branches missed.">		} else if (name.indexOf(EvaluationConstants.CLOSED_BRACE) &gt; -1) {</span>
<span class="nc" id="L1486">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a closed brace character.&quot;);
<span class="nc bnc" id="L1488" title="All 2 branches missed.">		} else if (name.indexOf(EvaluationConstants.POUND_SIGN) &gt; -1) {</span>
<span class="nc" id="L1489">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a pound sign character.&quot;);
		}

		// Check if name contains an operator character.
<span class="nc" id="L1494">		final Iterator operatorIterator = operators.iterator();</span>

<span class="nc bnc" id="L1496" title="All 2 branches missed.">		while (operatorIterator.hasNext()) {</span>
<span class="nc" id="L1497">			final Operator operator = (Operator) operatorIterator.next();</span>

<span class="nc bnc" id="L1499" title="All 2 branches missed.">			if (name.indexOf(operator.getSymbol()) &gt; -1) {</span>
<span class="nc" id="L1500">				throw new IllegalArgumentException(</span>
						&quot;A variable or function name &quot;
								+ &quot;can not contain an operator symbol.&quot;);
			}
<span class="nc" id="L1504">		}</span>

		// Check if name contains other special characters.
<span class="nc bnc" id="L1507" title="All 2 branches missed.">		if (name.indexOf(&quot;!&quot;) &gt; -1) {</span>
<span class="nc" id="L1508">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a special character.&quot;);
<span class="nc bnc" id="L1510" title="All 2 branches missed.">		} else if (name.indexOf(&quot;~&quot;) &gt; -1) {</span>
<span class="nc" id="L1511">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a special character.&quot;);
<span class="nc bnc" id="L1513" title="All 2 branches missed.">		} else if (name.indexOf(&quot;^&quot;) &gt; -1) {</span>
<span class="nc" id="L1514">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a special character.&quot;);
<span class="nc bnc" id="L1516" title="All 2 branches missed.">		} else if (name.indexOf(&quot;,&quot;) &gt; -1) {</span>
<span class="nc" id="L1517">			throw new IllegalArgumentException(&quot;A variable or function name &quot;</span>
					+ &quot;can not contain a special character.&quot;);
		}
<span class="nc" id="L1520">	}</span>

	/**
	 * This method loads the system functions is necessary.
	 */
	private void loadSystemFunctions() {
		// Install the math functions.
<span class="nc bnc" id="L1527" title="All 2 branches missed.">		if (loadMathFunctions) {</span>
<span class="nc" id="L1528">			final FunctionGroup mathFunctions = new MathFunctions();</span>

<span class="nc" id="L1530">			mathFunctions.load(this);</span>
		}

		// Install the string functions.
<span class="nc bnc" id="L1534" title="All 2 branches missed.">		if (loadStringFunctions) {</span>
<span class="nc" id="L1535">			final FunctionGroup stringFunctions = new StringFunctions();</span>

<span class="nc" id="L1537">			stringFunctions.load(this);</span>
		}
<span class="nc" id="L1539">	}</span>

	/**
	 * This method loads the system variables is necessary.
	 */
	private void loadSystemVariables() {
		// Install the math variables.
<span class="nc bnc" id="L1546" title="All 2 branches missed.">		if (loadMathVariables) {</span>
			// Add the two math variables.
<span class="nc" id="L1548">			putVariable(&quot;E&quot;, new Double(Math.E).toString());</span>
<span class="nc" id="L1549">			putVariable(&quot;PI&quot;, new Double(Math.PI).toString());</span>
		}
<span class="nc" id="L1551">	}</span>

	/**
	 * Replaces the variables in the expression with the values of the variables
	 * for this instance of the evaluator.
	 * 
	 * @param expression
	 *            The expression being processed.
	 * 
	 * @return A new expression with the variables replaced with their values.
	 * 
	 * @exception EvaluateException
	 *                Thrown is an error is encoutnered while processing the
	 *                expression.
	 */
	public String replaceVariables(final String expression)
			throws EvaluationException {

<span class="nc" id="L1569">		int openIndex = expression.indexOf(EvaluationConstants.OPEN_VARIABLE);</span>

<span class="nc bnc" id="L1571" title="All 2 branches missed.">		if (openIndex &lt; 0) {</span>
<span class="nc" id="L1572">			return expression;</span>
		}

<span class="nc" id="L1575">		String replacedExpression = expression;</span>

<span class="nc bnc" id="L1577" title="All 2 branches missed.">		while (openIndex &gt;= 0) {</span>

<span class="nc" id="L1579">			int closedIndex = -1;</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">			if (openIndex &gt;= 0) {</span>

<span class="nc" id="L1582">				closedIndex = replacedExpression.indexOf(</span>
						EvaluationConstants.CLOSED_VARIABLE, openIndex + 1);
<span class="nc bnc" id="L1584" title="All 2 branches missed.">				if (closedIndex &gt; openIndex) {</span>

<span class="nc" id="L1586">					String variableName = replacedExpression.substring(</span>
							openIndex
									+ EvaluationConstants.OPEN_VARIABLE
<span class="nc" id="L1589">											.length(), closedIndex);</span>
					
					// Validate that the variable name is valid.
					try {
<span class="nc" id="L1593">						isValidName(variableName);</span>
<span class="nc" id="L1594">					} catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L1595">						throw new EvaluationException(&quot;Invalid variable name of \&quot;&quot;</span>
								+ variableName + &quot;\&quot;.&quot;, iae);
<span class="nc" id="L1597">					}</span>
					
<span class="nc" id="L1599">					String variableValue = getVariableValue(variableName);</span>

<span class="nc" id="L1601">					String variableString = EvaluationConstants.OPEN_VARIABLE</span>
							+ variableName
							+ EvaluationConstants.CLOSED_VARIABLE;

<span class="nc" id="L1605">					replacedExpression = EvaluationHelper.replaceAll(</span>
							replacedExpression, variableString, variableValue);
				} else {

					break;
				}
			}

			// Start looking at the beginning of the string, since
			// the length string has changed and characters have moved
			// positions.
<span class="nc" id="L1616">			openIndex = replacedExpression.indexOf(</span>
					EvaluationConstants.OPEN_VARIABLE);
<span class="nc" id="L1618">		}</span>

		// If an open brace is left over, then a variable could not be replaced.
<span class="nc" id="L1621">		int openBraceIndex = replacedExpression</span>
<span class="nc" id="L1622">				.indexOf(EvaluationConstants.OPEN_VARIABLE);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">		if (openBraceIndex &gt; -1) {</span>
<span class="nc" id="L1624">			throw new EvaluationException(</span>
					&quot;A variable has not been closed (index=&quot; + openBraceIndex
							+ &quot;).&quot;);
		}

<span class="nc" id="L1629">		return replacedExpression;</span>
	}
	
	/**
	 * This method process nested function calls that may be in the arguments
	 * passed into a higher level function.
	 * 
	 * @param arguments The arguments to process.
	 * 
	 * @return The arguments with any nested function calls evaluated.
	 * 
	 * @throws EvaluationException Thrown if an error occurs.
	 */
	protected String processNestedFunctions(final String arguments)
			throws EvaluationException {

<span class="nc" id="L1645">		StringBuffer evaluatedArguments = new StringBuffer();</span>

		// Process nested function calls.
<span class="nc bnc" id="L1648" title="All 2 branches missed.">		if (arguments.length() &gt; 0) {</span>

<span class="nc" id="L1650">			Evaluator argumentsEvaluator = new Evaluator(quoteCharacter,</span>
					loadMathVariables, loadMathFunctions, loadStringFunctions,
					processNestedFunctions);
<span class="nc" id="L1653">			argumentsEvaluator.setFunctions(getFunctions());</span>
<span class="nc" id="L1654">			argumentsEvaluator.setVariables(getVariables());</span>
<span class="nc" id="L1655">			argumentsEvaluator.setVariableResolver(getVariableResolver());</span>

<span class="nc" id="L1657">			final ArgumentTokenizer tokenizer = new ArgumentTokenizer(</span>
					arguments, EvaluationConstants.FUNCTION_ARGUMENT_SEPARATOR);

<span class="nc" id="L1660">			List evalautedArgumentList = new ArrayList();</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">			while (tokenizer.hasMoreTokens()) {</span>

<span class="nc" id="L1663">				String argument = tokenizer.nextToken().trim();</span>

				try {
<span class="nc" id="L1666">					argument = argumentsEvaluator.evaluate(argument);</span>
<span class="nc" id="L1667">				} catch (Exception e) {</span>
<span class="nc" id="L1668">					throw new EvaluationException(e.getMessage(), e);</span>
<span class="nc" id="L1669">				}</span>

<span class="nc" id="L1671">				evalautedArgumentList.add(argument);</span>
<span class="nc" id="L1672">			}</span>

<span class="nc" id="L1674">			Iterator evaluatedArgumentIterator = evalautedArgumentList</span>
<span class="nc" id="L1675">					.iterator();</span>

<span class="nc bnc" id="L1677" title="All 2 branches missed.">			while (evaluatedArgumentIterator.hasNext()) {</span>

<span class="nc bnc" id="L1679" title="All 2 branches missed.">				if (evaluatedArguments.length() &gt; 0) {</span>

<span class="nc" id="L1681">					evaluatedArguments</span>
<span class="nc" id="L1682">							.append(EvaluationConstants.FUNCTION_ARGUMENT_SEPARATOR);</span>
				}

<span class="nc" id="L1685">				String evaluatedArgument = (String) evaluatedArgumentIterator</span>
<span class="nc" id="L1686">						.next();</span>
<span class="nc" id="L1687">				evaluatedArguments.append(evaluatedArgument);</span>
<span class="nc" id="L1688">			}</span>
		}

<span class="nc" id="L1691">		return evaluatedArguments.toString();</span>
	}

	/**
	 * Returns the value used during construction of this object to specify if
	 * math variables should be loaded.
	 * 
	 * @return the loadMathVariables
	 */
	public boolean isLoadMathVariables() {
<span class="nc" id="L1701">		return loadMathVariables;</span>
	}

	/**
	 * Returns the value used during construction of this object to specify if
	 * math functions should be loaded.
	 * 
	 * @return the loadMathFunctions
	 */
	public boolean getLoadMathFunctions() {
<span class="nc" id="L1711">		return loadMathFunctions;</span>
	}

	/**
	 * Returns the value used during construction of this object to specify if
	 * string functions should be loaded.
	 * 
	 * @return the loadStringFunctions
	 */
	public boolean getLoadStringFunctions() {
<span class="nc" id="L1721">		return loadStringFunctions;</span>
	}

	/**
	 * Returns the value used during construction of this object to specify if
	 * nested functions should be processed.
	 * 
	 * @return the processNestedFunctions
	 */
	public boolean getProcessNestedFunctions() {
<span class="nc" id="L1731">		return processNestedFunctions;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>